/*
 Generated by Sybase Unwired Platform 
 Compiler version - 2.0.1.314
*/ 

#import "RHM_Comercial_LocalKeyGenerator.h"
#import "SUPJsonObject.h"
#import "SUPJsonArray.h"
#import "SUPJsonMessage.h"
#import "SUPJsonReader.h"
#import "SUPConnectionWrapper.h"
#import "SUPLocalTransaction.h"
#import "SUPObjectNotFoundException.h"
#import "SUPNoSuchOperationException.h"
#import "SUPQuery.h"
#import "SUPQueueConnection.h"
#import "SUPResultSetWrapper.h"
#import "SUPStatementWrapper.h"
#import "SUPStatementBuilder.h"
#import "SUPEntityMetaData.h"
#import "SUPOperationMetaData.h"
#import "SUPAttributeMetaData.h"
#import "SUPAttributeMetaData_DC.h"
#import "SUPDatabaseMetaData.h"
#import "SUPSelectItem.h"
#import "SUPAttributeMap.h"
#import "SUPOperationMap.h"
#import "SUPDataType.h"
#import "MBODebugLogger.h"
#import "RHM_Comercial_RHM_ComercialDB.h"
#import "RHM_Comercial_KeyGenerator.h"
#import "RHM_Comercial_KeyGeneratorPK.h"
#import "RHM_Comercial_LocalKeyGeneratorPK.h"
#import "RHM_Comercial_LogRecordImpl.h"
#import "SUPCallbackHandler.h"
#import "RHM_Comercial_Clientes.h"
#import "MBODebugSettings.h"

static NSObject<SUPCallbackHandler>* _callbackHandler = nil;

@interface RHM_Comercial_LocalKeyGenerator(private)
- (void)bind:(id<SUPResultSetWrapper>)resultSet;
+ (RHM_Comercial_LocalKeyGenerator*)find:(RHM_Comercial_LocalKeyGeneratorPK*)id inTable:(SUPEntityTable)table;
+ (void)importData:(RHM_Comercial_LocalKeyGenerator*)serverEntity:(SUPJsonObject*)jsonObject;
- (void)merge:(RHM_Comercial_LocalKeyGenerator*)entity withJson:(SUPJsonObject*)json;
- (void)setAllAttributesFrom:(RHM_Comercial_LocalKeyGenerator*)other;
@end
@implementation RHM_Comercial_LocalKeyGenerator

@synthesize firstId = _firstId;
@synthesize lastId = _lastId;
@synthesize nextId = _nextId;
@synthesize remoteId = _remoteId;
@synthesize batchId = _batchId;

- (NSString*)remoteId
{
    return _remoteId;
}

- (int64_t)batchId
{
    return _batchId;
}

- (void)setFirstId:(int64_t)newFirstId
{
    if (newFirstId != self->_firstId)
    {
        self->_firstId = newFirstId;
        self->_isDirty = YES;
    }
}

- (void)setLastId:(int64_t)newLastId
{
    if (newLastId != self->_lastId)
    {
        self->_lastId = newLastId;
        self->_isDirty = YES;
    }
}

- (void)setNextId:(int64_t)newNextId
{
    if (newNextId != self->_nextId)
    {
        self->_nextId = newNextId;
        self->_isDirty = YES;
    }
}

- (void)setRemoteId:(NSString*)newRemoteId
{
    if (newRemoteId != self->_remoteId)
    {
		[self->_remoteId release];
        self->_remoteId = [newRemoteId retain];
        self->_isNew = YES;
    }
}

- (void)setBatchId:(int64_t)newBatchId
{
    if (newBatchId != self->_batchId)
    {
        self->_batchId = newBatchId;
        self->_isNew = YES;
    }
}

static RHM_Comercial_LocalKeyGenerator *instance = nil;
 
+ (RHM_Comercial_LocalKeyGenerator*)instance
{
    @synchronized(self) {
        if (instance == nil) {
            instance = [[self alloc] init];
        }
    }
    return instance;
}




- (id)initFromJson:(SUPJsonObject*)json:(int32_t)flags
{
    if (json == nil)
    {
        [self release];
        return nil;
    }
    if ((self = [super init]))
    {
        [self readJson:json:flags];
    }
    return self;   
}

- (void)readJson:(SUPJsonObject*)json:(int32_t)flags
{
        if ([json containsKey:@"firstId"])
    {
        self.firstId = [json getLong:@"firstId"];
    }
        if ([json containsKey:@"lastId"])
    {
        self.lastId = [json getLong:@"lastId"];
    }
        if ([json containsKey:@"nextId"])
    {
        self.nextId = [json getLong:@"nextId"];
    }
        if ([json containsKey:@"remoteId"])
    {
        self.remoteId = [json getString:@"remoteId"];
    }
        if ([json containsKey:@"batchId"])
    {
        self.batchId = [json getLong:@"batchId"];
    }
    if ([json containsKey:@"_op"])
    {
    	unichar op = [json getChar:@"_op"];
    	self->_isNew = (op == PendingCreate);
    	self->_isDirty = (op == PendingUpdate);
    	self->_isDeleted = (op == PendingDelete);
    } else {
    	self->_isNew = YES;
    	self->_isDirty = NO;
    	self->_isDeleted = NO;
    }
}

- (SUPJsonObject*)json:(int32_t)flags
{
    SUPJsonObject *newJson = [[SUPJsonObject alloc] init];
	BOOL all = YES;
	if (self.isNew || self.isCreated)
	{
	    [newJson setChar:@"_op":PendingCreate];
	}
	else if (self.isDirty || self.isUpdated)
	{
	    [newJson setChar:@"_op":PendingUpdate];
	}
	else if ([self isDeleted])
	{
	    [newJson setChar:@"_op":PendingDelete];
	}
	else if ((flags & 2) == 2)
	{
	    [newJson setChar:@"_op":HasPendingChild];
		all = NO;
	}
	[newJson setString:@"remoteId":self.remoteId];
	[newJson setLong:@"batchId":self.batchId];
	if (all)
	{
	    [newJson setLong:@"firstId":self.firstId];
	    [newJson setLong:@"lastId":self.lastId];
	    [newJson setLong:@"nextId":self.nextId];
	}
    [newJson autorelease];
    return newJson;
}
+ (SUPObjectList*)fromJSONList:(SUPJsonArray*)jsonArray
{
	if(jsonArray == nil)
		return nil;
	
	SUPObjectList* instanceList = [[SUPObjectList alloc] initWithCapacity:1];
	if(instanceList == nil)
		return nil;

	for (SUPJsonObject* jsonObject in jsonArray)
	{
	    RHM_Comercial_LocalKeyGenerator* inst = [[RHM_Comercial_LocalKeyGenerator alloc] initFromJson:jsonObject:0];
	    [instanceList add:inst];
	    [inst release];
	}
	return instanceList;
}

+ (SUPJsonArray*)toJSONList:(SUPObjectList*)instanceList
{
	SUPJsonArray* jsonArray = [[SUPJsonArray alloc] init];
	[jsonArray autorelease];
	for (RHM_Comercial_LocalKeyGenerator* inst in instanceList)
	{
		[jsonArray add:[inst json:0]];
	}
	return jsonArray;
}
- (void)dealloc
{
    if(_remoteId)
    {
        [_remoteId release];
        _remoteId = nil;
    }
	[super dealloc];
}

- (void)bind:(id<SUPResultSetWrapper>)resultSet
{
    @try
    {
        self.firstId = [resultSet getLong:1:@"first_id"];
        self.lastId = [resultSet getLong:2:@"last_id"];
        self.nextId = [resultSet getLong:3:@"next_id"];
        self.remoteId = [resultSet getString:4:@"remote_id"];
        self.batchId = [resultSet getLong:5:@"batch_id"];
                        [self setOriginalState:nil];
        self->_originalStateValid = NO;
                                                self->_isNew = NO;
        self->_isDirty = NO;
        self->_isDeleted = NO;
    }
    @catch (SUPPersistenceException *spe)
    {
        MBOLogPersistenceException(SUPCLIENTRT_TEMPLATE_PERSISTENCEEXCEPTIONMSG,@"bind",[spe message]);
    }
}

- (void)clearRelationshipObjects
{
}

- (void)copyAll:(RHM_Comercial_LocalKeyGenerator*)other
{
	[self copyAll:other withParent:(SUPAbstractEntity*)other];
}


- (void)copyAll:(RHM_Comercial_LocalKeyGenerator*)other withParent:(SUPAbstractEntity*)parent
{
    [self setFirstId:other.firstId];
    
    [self setLastId:other.lastId];
    
    [self setNextId:other.nextId];
    
    [self setRemoteId:other.remoteId];
    
    [self setBatchId:other.batchId];
    
	self->_isNew = other->_isNew;

}

- (void)create
{
	[super create];
}

- (void)delete
{
	[super delete];
}

- (RHM_Comercial_RHM_ComercialDB*)database
{
   return [RHM_Comercial_RHM_ComercialDB instance];
}

+ (RHM_Comercial_LocalKeyGenerator*)find_by_id_string:(NSString*)id_string
{
    if(id_string == nil) return nil;
	RHM_Comercial_LocalKeyGeneratorPK* key;
    key = [[RHM_Comercial_LocalKeyGeneratorPK alloc] initFromJson:[SUPJsonReader read:id_string]:0];
    [key autorelease];
    return [RHM_Comercial_LocalKeyGenerator find:key];
	
}

+ (RHM_Comercial_LocalKeyGenerator*)find:(RHM_Comercial_LocalKeyGeneratorPK*)id
{
	return [self find:id inTable:MainEntityTable];
}

+ (RHM_Comercial_LocalKeyGenerator*)find:(RHM_Comercial_LocalKeyGeneratorPK*)id_ inTable:(SUPEntityTable)table
{
    RHM_Comercial_LocalKeyGenerator* result = nil;
	RHM_Comercial_LocalKeyGenerator* downloadState = nil;
    id<SUPStatementWrapper> preparedStatement = nil;
    id<SUPConnectionWrapper> connection = nil;
    @try
    {
        [[RHM_Comercial_RHM_ComercialDB dblock] readLock];
    
    	connection = [RHM_Comercial_RHM_ComercialDB getConnectionWrapper];
    	//@synchronized(connection)
    	{
        	@try
        	{
            	if (table == MainEntityTable)
            	{
                	preparedStatement = [connection prepareStatement:@"select \"first_id\",\"last_id\",\"next_id\",\"remote_id\",\"batch_id\" from co_rhm_comercial_1_0_localkeygenerator where \"remote_id\"=? and \"batch_id\"=?"];
            	}
            	else
            	{
                	preparedStatement = [connection prepareStatement:@"select \"first_id\",\"last_id\",\"next_id\",\"remote_id\",\"batch_id\" from co_rhm_comercial_1_0_localkeygenerator_os where \"remote_id\"=? and \"batch_id\"=?"];
            	}
            	[preparedStatement setString:1:@"remoteId":id_.remoteId];
            	[preparedStatement setLong:2:@"batchId":id_.batchId];
            	id<SUPResultSetWrapper> resultSet = [preparedStatement executeQuery];
            	while ([resultSet next])
            	{
            		if(result) [result release];
                	result = [[RHM_Comercial_LocalKeyGenerator alloc] init];
                	[result bind:resultSet];
                	if (table == OriginalStateEntityTable)
                	{
                    	result->_pending = false;
                    	result->_pendingChange = NotPending;
                	}
                	if (result.pending)
                	{
                    	break;
                	}
                	else
                	{
 	              		downloadState = [RHM_Comercial_LocalKeyGenerator getInstance];
                		[downloadState copyAll:result];
                	}
            	}
            	[resultSet close];      
        	}
        	@catch (SUPPersistenceException *spe)
        	{
            	@throw spe;
        	}
    	}
    }
    @catch (SUPPersistenceException *spe)
    {
        MBOLogPersistenceException(SUPCLIENTRT_TEMPLATE_PERSISTENCEEXCEPTIONMSG,@"find",[spe message]);
    }
    @finally
    {
    	if(preparedStatement) [preparedStatement close];
        [connection releaseToPool];
        [[RHM_Comercial_RHM_ComercialDB dblock] unlock];
    }
    if(result)
    {
    	if(result.pending)
    		result.downloadState = (SUPAbstractEntity*)downloadState;
  		//if(result != downloadState)
  		//	[downloadState release];
    }
    [result autorelease];
    return result;
}

+ (id<SUPSynchronizationGroup>)getSynchronizationGroup
{
	return [RHM_Comercial_RHM_ComercialDB getSyncGroupForName:@""];
}


- (id<SUPStatementWrapper>)getCreateStatement:(id<SUPConnectionWrapper>)connection forTable:(SUPEntityTable)table;
{
    id<SUPStatementWrapper> preparedStatement;
    preparedStatement = [connection prepareStatement:@"insert into co_rhm_comercial_1_0_localkeygenerator (\"first_id\",\"last_id\",\"next_id\",\"remote_id\",\"batch_id\") values (?,?,?,?,?)"];
    // Add updated values
    [preparedStatement setLong:1:@"first_id":self.firstId];
    [preparedStatement setLong:2:@"last_id":self.lastId];
    [preparedStatement setLong:3:@"next_id":self.nextId];
	if(self.remoteId == nil)
		self.remoteId = @"";
		//RHM_Comercial_LocalKeyGenerator getCreateStatement:remoteId not allowed to be null
    [preparedStatement setString:4:@"remote_id":self.remoteId];
    [preparedStatement setLong:5:@"batch_id":self.batchId];
	return preparedStatement;
}

- (id<SUPStatementWrapper>)getDeleteStatement:(id<SUPConnectionWrapper>)connection forTable:(SUPEntityTable)table;
{
    id<SUPStatementWrapper> preparedStatement;
    preparedStatement = [connection prepareStatement:@"delete from co_rhm_comercial_1_0_localkeygenerator where \"remote_id\"=? and \"batch_id\"=?"];
    // Fill in values for "where" clause
    [preparedStatement setString:1:@"remote_id":self.remoteId];
    [preparedStatement setLong:2:@"batch_id":self.batchId];
	return preparedStatement;
}

- (id<SUPStatementWrapper>)getUpdateStatement:(id<SUPConnectionWrapper>)connection forTable:(SUPEntityTable)table;
{
    id<SUPStatementWrapper> preparedStatement;
	preparedStatement = [connection prepareStatement:@"update co_rhm_comercial_1_0_localkeygenerator set \"first_id\"=?,\"last_id\"=?,\"next_id\"=? where \"remote_id\"=? and \"batch_id\"=?"];
    // Add updated values
    int parameterIndex = 0;
    parameterIndex++;
    [preparedStatement setLong:parameterIndex:@"first_id":self.firstId];
    parameterIndex++;
    [preparedStatement setLong:parameterIndex:@"last_id":self.lastId];
    parameterIndex++;
    [preparedStatement setLong:parameterIndex:@"next_id":self.nextId];
    // Fill in values for "where" clause
    parameterIndex++;
    [preparedStatement setString:parameterIndex:@"remote_id":self.remoteId];
    parameterIndex++;
    [preparedStatement setLong:parameterIndex:@"batch_id":self.batchId];
	return preparedStatement;
}

- (RHM_Comercial_LocalKeyGeneratorPK*)_pk
{
	return [self id];
}

- (RHM_Comercial_LocalKeyGeneratorPK*)id
{
    RHM_Comercial_LocalKeyGeneratorPK* key = [[RHM_Comercial_LocalKeyGeneratorPK alloc] init];
    [key autorelease];
    key.remoteId = self.remoteId;    
    key.batchId = self.batchId;    
    return key;
}

- (NSString*)keyToString
{
	return [[self id] description];
}



+ (RHM_Comercial_LocalKeyGenerator*)load:(RHM_Comercial_LocalKeyGeneratorPK*)id
{
	RHM_Comercial_LocalKeyGenerator* entity = [self find:id inTable:MainEntityTable];
	//RHM_Comercial_LocalKeyGenerator* entity = [self find:id];
    if (entity == nil)
    {
		@throw [SUPObjectNotFoundException withMessage:@"-load: in RHM_Comercial_LocalKeyGenerator: entity not found in database"];
    }
    return entity;
}

static SUPEntityMetaData* RHM_Comercial_LocalKeyGenerator_META_DATA;
static BOOL _valid_ = NO;

+ (SUPEntityMetaData*)metaData
{
    if (! (_valid_))
    {
       RHM_Comercial_LocalKeyGenerator_META_DATA = [SUPEntityMetaData getInstance];
       RHM_Comercial_LocalKeyGenerator_META_DATA.id = _ENTITY_NUMBER_FOR_RHM_Comercial_LocalKeyGenerator_;
       RHM_Comercial_LocalKeyGenerator_META_DATA.name = @"LocalKeyGenerator";
       [RHM_Comercial_LocalKeyGenerator_META_DATA setClass:[RHM_Comercial_LocalKeyGenerator class]];

	   RHM_Comercial_LocalKeyGenerator_META_DATA.isClientOnly = YES;

       // Handle attributes
       
       	SUPObjectList *attributes = [SUPObjectList getInstance];
		SUPAttributeMetaData_DC* a_firstId = [RHM_Comercial_RHM_ComercialDB createAttributeMetaData:1:(SUPString)@"firstId":[SUPDataType forName:@"long"]];
		[a_firstId setColumn:@"\"first_id\""];
		[a_firstId setMaxLength:-1];
		[a_firstId setPrecision:0];
		[a_firstId setScale:0];
		[a_firstId setIsKey:NO];
		SUPAttributeMetaData_DC* a_lastId = [RHM_Comercial_RHM_ComercialDB createAttributeMetaData:2:(SUPString)@"lastId":[SUPDataType forName:@"long"]];
		[a_lastId setColumn:@"\"last_id\""];
		[a_lastId setMaxLength:-1];
		[a_lastId setPrecision:0];
		[a_lastId setScale:0];
		[a_lastId setIsKey:NO];
		SUPAttributeMetaData_DC* a_nextId = [RHM_Comercial_RHM_ComercialDB createAttributeMetaData:3:(SUPString)@"nextId":[SUPDataType forName:@"long"]];
		[a_nextId setColumn:@"\"next_id\""];
		[a_nextId setMaxLength:-1];
		[a_nextId setPrecision:0];
		[a_nextId setScale:0];
		[a_nextId setIsKey:NO];
		SUPAttributeMetaData_DC* a_remoteId = [RHM_Comercial_RHM_ComercialDB createAttributeMetaData:4:(SUPString)@"remoteId":[SUPDataType forName:@"string"]];
		[a_remoteId setColumn:@"\"remote_id\""];
		[a_remoteId setMaxLength:300];
		[a_remoteId setPrecision:0];
		[a_remoteId setScale:0];
		[a_remoteId setIsKey:YES];
		SUPAttributeMetaData_DC* a_batchId = [RHM_Comercial_RHM_ComercialDB createAttributeMetaData:5:(SUPString)@"batchId":[SUPDataType forName:@"long"]];
		[a_batchId setColumn:@"\"batch_id\""];
		[a_batchId setMaxLength:-1];
		[a_batchId setPrecision:0];
		[a_batchId setScale:0];
		[a_batchId setIsKey:YES];
 		
 		[attributes addThis:a_firstId];
 		[attributes addThis:a_lastId];
 		[attributes addThis:a_nextId];
 		[attributes addThis:a_remoteId];
 		[attributes addThis:a_batchId];
 		RHM_Comercial_LocalKeyGenerator_META_DATA.attributes = attributes;
 		
 		SUPAttributeMap * attributeMap = [SUPAttributeMap getInstance];
    	[attributeMap setAttributes:attributes];
    	RHM_Comercial_LocalKeyGenerator_META_DATA.attributeMap = [attributeMap finishInit];
 
 		// Handle operations
 		SUPOperationMetaData* o_findAll_0 = [RHM_Comercial_RHM_ComercialDB createOperationMetaData:1:(SUPString)@"findAll":[SUPDataType forName:@"LocalKeyGenerator*"]:true];
		[o_findAll_0 setIsStatic:YES];
		[o_findAll_0 setIsCreate:NO];
		[o_findAll_0 setIsUpdate:NO];
		[o_findAll_0 setIsDelete:NO]; 		
 		[o_findAll_0 finishInit];
 		SUPOperationMetaData* o_refresh_0 = [RHM_Comercial_RHM_ComercialDB createOperationMetaData:2:(SUPString)@"refresh":[SUPDataType forName:@"void"]:true];
		[o_refresh_0 setIsStatic:NO];
		[o_refresh_0 setIsCreate:NO];
		[o_refresh_0 setIsUpdate:NO];
		[o_refresh_0 setIsDelete:NO]; 		
 		[o_refresh_0 finishInit];
 		SUPOperationMetaData* o_save_0 = [RHM_Comercial_RHM_ComercialDB createOperationMetaData:3:(SUPString)@"save":[SUPDataType forName:@"void"]:true];
		[o_save_0 setIsStatic:NO];
		[o_save_0 setIsCreate:NO];
		[o_save_0 setIsUpdate:NO];
		[o_save_0 setIsDelete:NO]; 		
 		[o_save_0 finishInit];
 
  		SUPObjectList *operations = [SUPObjectList listWithCapacity:3];
 		[operations addThis:o_findAll_0];
 		[operations addThis:o_refresh_0];
 		[operations addThis:o_save_0];
 		RHM_Comercial_LocalKeyGenerator_META_DATA.operations = operations;
 		
		SUPOperationMap *operationMap = [SUPOperationMap getInstance];
		[operationMap setOperations:operations];
		RHM_Comercial_LocalKeyGenerator_META_DATA.operationMap = [operationMap finishInit];
		
		RHM_Comercial_LocalKeyGenerator_META_DATA.table = @"\"co_rhm_comercial_1_0_localkeygenerator\"";

 		[RHM_Comercial_LocalKeyGenerator_META_DATA retain];
     	_valid_ = YES;

	}
	return RHM_Comercial_LocalKeyGenerator_META_DATA;
}

- (void)merge:(RHM_Comercial_LocalKeyGenerator*)entity withJson:(SUPJsonObject*)json
{
	[super merge:entity withJson:json];
    if(![json containsKey:@"firstId"] )
    {
    	self.firstId = entity.firstId;
    }
    else if(![json getLong:@"firstId"])
    {
    	self.firstId = entity.firstId;
    }
    if(![json containsKey:@"lastId"] )
    {
    	self.lastId = entity.lastId;
    }
    else if(![json getLong:@"lastId"])
    {
    	self.lastId = entity.lastId;
    }
    if(![json containsKey:@"nextId"] )
    {
    	self.nextId = entity.nextId;
    }
    else if(![json getLong:@"nextId"])
    {
    	self.nextId = entity.nextId;
    }
    if(![json containsKey:@"remoteId"] )
    {
    	self.remoteId = entity.remoteId;
    }
    else if(![json getString:@"remoteId"])
    {
    	self.remoteId = entity.remoteId;
    }
    if(![json containsKey:@"batchId"] )
    {
    	self.batchId = entity.batchId;
    }
    else if(![json getLong:@"batchId"])
    {
    	self.batchId = entity.batchId;
    }
}

+ (RHM_Comercial_LocalKeyGenerator*)getInstance
{
    RHM_Comercial_LocalKeyGenerator* me = [[RHM_Comercial_LocalKeyGenerator alloc] init];
    [me autorelease];
    return me;
}

- (SUPObjectList*)getLogRecords
{
    SUPQuery *query = [SUPQuery getInstance];
    [query from:@"LogRecordImpl":@"a"];
    query.testCriteria = (SUPTestCriteria*)[[SUPAttributeTest match:@"component":@"LocalKeyGenerator"] and:[SUPAttributeTest match:@"entityKey":[self keyToString]]];
    [query orderBy:@"requestId":[SUPSortOrder DESCENDING]];

    RHM_Comercial_LogRecordImplList* list = [RHM_Comercial_LogRecordImpl findWithQuery:query];
    return (SUPObjectList*)list;
}

- (id<SUPLogRecord>)createLogRecord:(int32_t)level withMessage:(NSString*)message
{
    {
        RHM_Comercial_LogRecordImpl *log = [[RHM_Comercial_LogRecordImpl alloc] init];
        //log.level = [NSString stringWithFormat:@"%ld",[SUPLogLevel fromString:level]];
        log.level = level;
        log.message = message;
        log.messageId = [RHM_Comercial_KeyGenerator generateId];
        log.requestId = [NSString stringWithFormat:@"%ld",log.messageId];
        NSDate *timestamp = [NSDate dateWithTimeIntervalSinceNow:0];
        log.timestamp = timestamp;
        log.code = CLIENT_ENTITY_CREATED_LOGRECORD_CODE;
        log.component = @"LocalKeyGenerator";
        log.entityKey = [self keyToString];
        [log save];
        [log autorelease];
        return log;
    }
}

- (void)setAllAttributesFrom:(RHM_Comercial_LocalKeyGenerator*)other
{
	// Child lists are set to nil, to prevent infinite recursion
	// when this method is used inside the bind: method
    	[self setFirstId:other.firstId];
    	[self setLastId:other.lastId];
    	[self setNextId:other.nextId];
    	[self setRemoteId:other.remoteId];
    	[self setBatchId:other.batchId];
}

+ (NSObject<SUPCallbackHandler>*)callbackHandler
{
	return _callbackHandler;
}

+ (void)registerCallbackHandler:(NSObject<SUPCallbackHandler>*)newCallbackHandler
{
	if(newCallbackHandler != _callbackHandler)
	{
		[_callbackHandler release];
		_callbackHandler = [newCallbackHandler retain];
	}
}

- (void)refresh
{
    if (!self.isNew)
    {
        RHM_Comercial_LocalKeyGenerator* entity = [RHM_Comercial_LocalKeyGenerator load:[self id]];
        [self copyAll:entity];
        _isNew = NO;
        _isDirty = NO;
    }
}











- (NSString*)toString
{
	NSString* str = [NSString stringWithFormat:@"\
	LocalKeyGenerator = \n\
	    firstId = %qi,\n\
	    lastId = %qi,\n\
	    nextId = %qi,\n\
	    remoteId = %@,\n\
	    batchId = %qi,\n\
	    isNew = %i,\n\
        isDirty = %i,\n\
        isDeleted = %i,\n\
	\n"
    	,self.firstId
    	,self.lastId
    	,self.nextId
    	,self.remoteId
    	,self.batchId
		,self.isNew
		,self.isDirty
		,self.isDeleted
	];
	return str;

}

- (NSString*)description
{
	return [self toString];
}

- (void)save
{
    if (self->_isNew)
    {
        [self create];
    }
    else if (self->_isDirty)
    {
        [self update];
    }
}

- (void)createOrUpdateClientOnly
{
   	id<SUPConnectionWrapper> connection = nil;
    id<SUPStatementWrapper> statement = nil;
    @try
    {
        [[RHM_Comercial_RHM_ComercialDB dblock] writeLock];
    	connection = [RHM_Comercial_RHM_ComercialDB getConnectionWrapper];
        RHM_Comercial_LocalKeyGenerator *ms = [RHM_Comercial_LocalKeyGenerator find:[self id] inTable:MainEntityTable];
		if(ms)
		{
			statement = [self getUpdateStatement:connection forTable:MainEntityTable];
			[statement executeUpdate:YES];
		} else {
		    statement = [self getCreateStatement:connection forTable:MainEntityTable];
			[statement executeInsert];
		}
			
		self->_isNew = NO;
		self->_isDirty = NO;
		self->_isDeleted = NO;
	}
	@catch (SUPPersistenceException *spe)
    {
        MBOLogPersistenceException(SUPCLIENTRT_TEMPLATE_PERSISTENCEEXCEPTIONMSG,@"createPending",[spe message]);
    }
    @finally
    {
        [statement close];
        [connection releaseToPool];
        [[RHM_Comercial_RHM_ComercialDB dblock] unlock];
    }    
}

- (void)createPending:(BOOL)isPending
{
	[self createOrUpdateClientOnly];
}

- (void)updatePending:(BOOL)isPending
{
	[self createOrUpdateClientOnly];
}




- (SUPAbstractEntity*)topLevelParent
{
	return self;
}

- (void)update
{
	[super update];
}

+ (BOOL)initSync
{
    BOOL ok = NO;
    SUPLocalTransaction* transaction = nil;
    id<SUPConnectionWrapper> connection = nil;
    @try
    {
        [[RHM_Comercial_RHM_ComercialDB dblock] writeLock];
        id<SUPConnectionWrapper> connection = [RHM_Comercial_RHM_ComercialDB getConnectionWrapper];
        transaction = ([connection inTransaction] ? nil : [RHM_Comercial_RHM_ComercialDB beginTransaction]);

        SUPObjectList* list = [RHM_Comercial_LocalKeyGenerator findAll];
        int32_t size = [list size];
        if (size == 0)
        {
            RHM_Comercial_LocalKeyGenerator* batch1 = [[[RHM_Comercial_LocalKeyGenerator alloc] init] autorelease];
            batch1.remoteId = @".";
            batch1.batchId = 1;
            batch1.lastId = -1;
            [batch1 create];
                
            RHM_Comercial_LocalKeyGenerator* batch2 = [[[RHM_Comercial_LocalKeyGenerator alloc] init] autorelease];
            batch2.remoteId = @".";
            batch2.batchId = 2;
            batch2.lastId = -1;
            [batch2 create];
                                
            ok = YES;
            return YES;
        }
        if (size == 4)
        {
            for (RHM_Comercial_LocalKeyGenerator* item in list)
            {
                if (item.lastId == -1)
                {
                    [item delete];
                }                                
            }
            list = [RHM_Comercial_LocalKeyGenerator findAll];
        }
        RHM_Comercial_LocalKeyGenerator* batch = [list item:0];
        ok = YES;
        int64_t last = batch.lastId;
        int64_t next = batch.nextId;
        return (last == -1) || (next > last);
    }
    @finally
    {
        if (ok)
        {
            [transaction commit];
        }
        else
        {
            [transaction rollback];
        }
        [connection releaseToPool];
        [[RHM_Comercial_RHM_ComercialDB dblock] unlock];
    }
    return NO;
}

- (void)nextBatch
{
    id<SUPConnectionWrapper> connection = nil;
    @try
    {
        [[RHM_Comercial_RHM_ComercialDB dblock] writeLock];
        connection = [RHM_Comercial_RHM_ComercialDB getConnectionWrapper];
        SUPLocalTransaction* transaction = ([connection inTransaction] ? nil : [RHM_Comercial_RHM_ComercialDB beginTransaction]);      
        RHM_Comercial_LocalKeyGeneratorPK* pk = [[RHM_Comercial_LocalKeyGeneratorPK alloc] init];
        [pk autorelease];
        [pk setRemoteId:@"*"];
        [pk setBatchId:1];
        RHM_Comercial_LocalKeyGenerator* batch = [RHM_Comercial_LocalKeyGenerator find:pk];
        if (batch == nil)
        {
            batch = [[[RHM_Comercial_LocalKeyGenerator alloc] init] autorelease];
            batch.remoteId = [pk remoteId];
            batch.batchId = [pk batchId];
            /*
            batch.firstId = 1;
                        batch.nextId = 1 + 100000; 
            batch.lastId = INT_MAX;
            [batch save];
            self.remoteId = @"*";
            self.batchId = 1;
            self.firstId = 1;
            self.nextId = 1;
            self.lastId = 100000;
            */
            // new code to guarantee unique local keys -- use number of seconds since 6/1/2009
            long time = [[NSDate date] timeIntervalSince1970] - 1243814400;
            batch.firstId = time;
            batch.nextId = batch.firstId + 1000; 
            batch.lastId = INT_MAX;
            [batch save];
            self.remoteId = @"*";
            self.batchId = batch.batchId;
            self.firstId = batch.firstId;
            self.nextId = batch.nextId;
            self.lastId = batch.lastId;
            
        }
        else
        {
            int64_t first = [batch nextId];
            int64_t next = first + 100000;
            batch.nextId = next;
            [batch save];
            self.firstId = first;
            self.nextId = first;
            self.lastId = 100000;
        }       
        if(transaction) [transaction commit];
    }
    @finally
    {
        [connection releaseToPool];
        [[RHM_Comercial_RHM_ComercialDB dblock] unlock];
    }
}

+ (void)saveBatch
{
    id<SUPConnectionWrapper> connection = nil;
    RHM_Comercial_LocalKeyGenerator* instance = [RHM_Comercial_LocalKeyGenerator instance];
    @try
    {
        [[RHM_Comercial_RHM_ComercialDB dblock] writeLock];
        connection = [RHM_Comercial_RHM_ComercialDB getConnectionWrapper];
        SUPLocalTransaction* transaction = ([connection inTransaction] ? nil : [RHM_Comercial_RHM_ComercialDB beginTransaction]);
        [instance update];
        if(transaction) [transaction commit];
    }
    @finally
    {
        [connection releaseToPool];
        [[RHM_Comercial_RHM_ComercialDB dblock] unlock];
    }
}

+ (NSString *)generateGuid
{
	return [SUPStringUtil guid32];
}


/*!
  @method
  @abstract Generated class method 
  @throws SUPPersistenceException
 */
+ (int64_t)generateId
{
    int64_t id = 0;
    RHM_Comercial_LocalKeyGenerator* instance = [RHM_Comercial_LocalKeyGenerator instance];
    @synchronized(instance)
    {
        if (([instance batchId] == 0) || ([instance nextId] > [instance lastId]))
        {
            [instance nextBatch];
            instance.batchId = 1;
        }
        id = [instance nextId];
        instance.nextId = id + 1;
    }
    return id;
}



+ (SUPObjectList*)findAll
{
	return [self findAll:0 take:-1]; 
}


	

+ (SUPObjectList*)findAll:(int32_t)skip take:(int32_t)take
{
	SUPObjectList* result = [[[SUPObjectList alloc] init] autorelease];
	NSMutableString *sql = nil;
	id<SUPStatementWrapper> preparedStatement = nil;
	id<SUPConnectionWrapper> connection = nil;
	id<SUPResultSetWrapper> resultSet = nil;
	
	@try
	{
	    [[RHM_Comercial_RHM_ComercialDB dblock] readLock];
		connection = [RHM_Comercial_RHM_ComercialDB getConnectionWrapper];
		sql = [[NSMutableString alloc] initWithCapacity:156];
	    [sql appendString:@"select x.\"first_id\",x.\"last_id\",x.\"next_id\",x.\"remote_id\",x.\"batch_id\" from \"co_rhm_comercial_1_0_localkeygenerator\" x order by x.\"first_id\""];
	    if(take != -1)
	        [sql appendFormat:@" limit %i",take];
	    if(skip != 0)
	        [sql appendFormat:@" offset %i",skip];
	
		preparedStatement = [connection prepareStatement:sql];
	            
	    resultSet = [preparedStatement executeQuery];
	    while ([resultSet next])
	    {
	        RHM_Comercial_LocalKeyGenerator* entity = [[RHM_Comercial_LocalKeyGenerator alloc] init];
	        [entity bind:resultSet];
	        [result add:entity];
			[entity release];
	    }
	}
	@catch (SUPPersistenceException *spe)
	{
	    MBOLogPersistenceException(SUPCLIENTRT_TEMPLATE_PERSISTENCEEXCEPTIONMSG,@"findAll",[spe message]);
	}
	@finally
	{
		[sql release];
		if(resultSet) [resultSet close];
		if(preparedStatement) [preparedStatement close];
	    [connection releaseToPool];
	    [[RHM_Comercial_RHM_ComercialDB dblock] unlock];
	}
	return result;
}

@end